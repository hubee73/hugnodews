<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Så‹Canvasæ—¶é—´çº¿</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
            overflow: auto; /* å…è®¸æ»šåŠ¨ */
            background-color: #f0f2f5;
            margin: 0;
            padding: 0;
        }
        canvas {
            display: block;
            cursor: default;
        }
        #canvas-container {
            position: relative;
            overflow: visible; /* å…è®¸å†…å®¹æº¢å‡º */
            width: 100%;
            height: 100vh;
        }
        .glass-panel {
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.5);
        }
        .glass-button {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(4px);
            border: 1px solid rgba(229, 231, 235, 0.5);
            transition: all 0.2s ease;
        }
        .glass-button:hover {
            transform: translateY(-1px);
            background: #fff;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .glass-button:active {
            transform: translateY(0);
        }
        /* éšè— datetime-local çš„é»˜è®¤å›¾æ ‡ (å¯é€‰, ä¿æŒç®€æ´) */
        input[type="datetime-local"]::-webkit-calendar-picker-indicator {
            /* (å¯ä»¥æ ¹æ®éœ€è¦è®¾ç½®æ ·å¼ï¼Œæˆ–ä¿æŒé»˜è®¤) */
            /* background: none;*/
        }
    </style>
</head>
<body class="w-screen h-screen m-0 p-0">

    <!-- Canvas å®¹å™¨ -->
    <div id="canvas-container" class="w-full h-full">
        <canvas id="timelineCanvas"></canvas>
    </div>

    <!-- å³ä¸Šè§’æŒ‰é’®: ä¿å­˜/è¯»å– -->
    <div class="glass-panel absolute top-4 right-4 flex gap-2 z-10">
        <button id="saveButton" class="glass-button px-4 py-2 bg-blue-600 text-white rounded-lg shadow-md hover:bg-blue-700 transition duration-300">
            ä¿å­˜
        </button>
        <label for="loadInput" class="glass-button cursor-pointer px-4 py-2 bg-green-600 text-white rounded-lg shadow-md hover:bg-green-700 transition duration-300">
            è¯»å–
        </label>
        <input type="file" id="loadInput" class="hidden" accept=".txt">
    </div>

    <!-- å·¦ä¸‹è§’æŒ‰é’®: ç¼©æ”¾ -->
    <div class="absolute bottom-6 left-6 flex gap-2 z-20">
        <div class="glass-panel rounded-xl p-1 shadow-lg flex">
            <button id="zoomInButton" id="zoomInBtn" class="w-10 h-10 flex items-center justify-center text-xl font-bold text-gray-700 hover:bg-white/50 rounded-lg transition-colors" title="æ”¾å¤§">+</button>
            <div class="w-[1px] bg-gray-300/50"></div>
            <button id="zoomOutButton" id="zoomOutBtn" class="w-10 h-10 flex items-center justify-center text-xl font-bold text-gray-700 hover:bg-white/50 rounded-lg transition-colors" title="ç¼©å°">-</button>
        </div>
    </div>

    <!-- äº‹ä»¶ç¼–è¾‘æ¨¡æ€æ¡† (é»˜è®¤éšè—) -->
    <div id="eventModal" class="fixed inset-0 bg-black/40 backdrop-blur-sm flex items-center justify-center p-4 transition-opacity opacity-0 pointer-events-none duration-300 z-50">
        <div class="modal-content glass-panel rounded-xl shadow-2xl w-full max-w-md p-8 transform scale-100 transition-all duration-300">
            <h3 id="modalTitle" class="text-2xl font-bold mb-6 text-gray-800">ç¼–è¾‘äº‹ä»¶</h3>
            <form id="eventForm">
                <div class="mb-4">
                    <label for="eventDate" class="block text-sm font-medium text-gray-700 mb-1">æ—¥æœŸå’Œæ—¶é—´</label>
                    <!-- ä½¿ç”¨ datetime-local -->
                    <input type="datetime-local" id="eventDate" class="w-full px-4 py-2.5 bg-white/50 border border-gray-200 rounded-lg focus:ring-2 focus:ring-blue-500 outline-none transition-all hover:border-blue-400" step="1" required>
                </div>
                <!-- ä¼˜å…ˆçº§æ”¹ä¸º Select 0-5 -->
                <div class="mb-4">
                    <label for="eventPriority" class="block text-sm font-medium text-gray-700 mb-1">ä¼˜å…ˆçº§ (0-5, 0æœ€é«˜)</label>
                    <select id="eventPriority" class="w-full flex-1 px-4 py-2.5 bg-white/50 border border-gray-200 rounded-lg focus:ring-2 focus:ring-blue-500 outline-none cursor-pointer transition-all hover:border-blue-400 font-bold">
                        <option value="0" data-color="#FF0000" style="color: #FF0000;">ğŸ”¥ 0 - ç´§æ€¥</option>
                        <option value="1" data-color="#FF8C00" style="color: #FF8C00;">âš¡ 1 - è¾ƒé«˜</option>
                        <option value="2" data-color="#FFD700" style="color: #FFD700;">â­ 2 - ä¸­ç­‰</option>
                        <option value="3" data-color="#00BFFF" style="color: #00BFFF;">ğŸ”¹ 3 - ä¸€èˆ¬</option>
                        <option value="4" data-color="#9370DB" style="color: #9370DB;">ğŸ”¸ 4 - è¾ƒä½</option>
                        <option value="5" data-color="#808080" style="color: #808080;">ğŸ’¤ 5 - å¾…å®š</option>
                    </select>
                </div>
                <div class="mb-4">
                    <label for="eventDescription" class="block text-sm font-medium text-gray-700 mb-1">æè¿°</label>
                    <input type="text" id="eventDescription" class="w-full px-4 py-2.5 bg-white/50 border border-gray-200 rounded-lg focus:ring-2 focus:ring-blue-500 outline-none transition-all hover:border-blue-400" required>
                </div>
                <div class="flex justify-end gap-3 mt-6">
                    <button type="button" id="cancelButton" class="px-5 py-2.5 rounded-lg text-gray-600 hover:bg-gray-100 transition-colors font-medium">
                        å–æ¶ˆ
                    </button>
                    <button type="submit" id="saveEventButton" class="px-5 py-2.5 bg-blue-600 hover:bg-blue-700 text-white rounded-lg shadow-lg shadow-blue-500/30 transition-all font-medium">
                        ä¿å­˜
                    </button>
                </div>
            </form>
        </div>
    </div>


    <script>
        /*
         * ========================================================================
         * Så‹CANVASæ—¶é—´çº¿
         * ========================================================================
         * ä¸»è¦åŠŸèƒ½æ€»ç»“å¦‚ä¸‹ï¼š
         *  1. æ ¸å¿ƒåŠŸèƒ½ä¸ç‰¹ç‚¹
         *     S å‹è·¯å¾„å¸ƒå±€ï¼šæ—¶é—´çº¿ä¸å†æ˜¯å•çº¯çš„ç›´çº¿ï¼Œè€Œæ˜¯æ ¹æ®çª—å£å¤§å°è‡ªåŠ¨è®¡ç®—å‡ºçš„ S å‹èœ¿èœ’è·¯å¾„ï¼ˆåŒ…å«ç›´çº¿æ®µå’Œåœ†å¼§è½¬è§’ï¼‰ï¼Œæœ‰æ•ˆåœ°åˆ©ç”¨äº†å‚ç›´å±å¹•ç©ºé—´ã€‚
         *     å®Œå…¨å“åº”å¼ï¼šç›‘å¬çª—å£ resize äº‹ä»¶ï¼Œå®æ—¶é‡æ–°è®¡ç®—è·¯å¾„å’ŒèŠ‚ç‚¹ä½ç½®ï¼Œä¿è¯åœ¨ä¸åŒå±å¹•å°ºå¯¸ä¸‹æ˜¾ç¤ºæ­£å¸¸ã€‚
         *     æ™ºèƒ½é˜²ç¢°æ’å¸ƒå±€ï¼š
         *        ç³»ç»Ÿä¼šæ ¹æ®äº‹ä»¶çš„æ—¶é—´æˆ³è®¡ç®—å…¶åœ¨è·¯å¾„ä¸Šçš„ç²¾ç¡®ä½ç½®ã€‚
         *        å…·æœ‰ç¢°æ’æ£€æµ‹æœºåˆ¶ï¼ˆprocessEventsLayoutï¼‰ï¼Œå¦‚æœæ–‡å­—æ ‡ç­¾å‘ç”Ÿé‡å ï¼Œä¼šè‡ªåŠ¨è°ƒæ•´æ ‡ç­¾ä½ç½®ï¼ˆä¸Šä¸‹äº¤æ›¿ï¼‰ã€‚
         *        å¦‚æœç©ºé—´ä¾ç„¶ä¸è¶³ï¼Œä½ä¼˜å…ˆçº§çš„äº‹ä»¶ä¼šç¼©ç•¥æ˜¾ç¤ºä¸ºä¸€ä¸ªå°åœ†ç‚¹ï¼ˆDotæ¨¡å¼ï¼‰ï¼Œé«˜ä¼˜å…ˆçº§äº‹ä»¶æ˜¾ç¤ºå®Œæ•´è¯¦æƒ…ï¼ˆFullæ¨¡å¼ï¼‰ã€‚
         *     å¹³æ»‘åŠ¨ç”»ï¼š
         *        åŒ…å«åŠ¨ç”»å¾ªç¯ï¼ˆrequestAnimationFrameï¼‰ï¼Œç”¨äºå¤„ç†ç¼©æ”¾å’Œäº‹ä»¶æ˜¾éšçš„è¿‡æ¸¡æ•ˆæœï¼ˆé€æ˜åº¦å’Œå¤§å°çš„ Lerp æ’å€¼åŠ¨ç”»ï¼‰ã€‚
         *  2. äº¤äº’èƒ½åŠ›
         *     äº‹ä»¶ CRUDï¼ˆå¢åˆ æ”¹æŸ¥ï¼‰ï¼š
         *        æŸ¥çœ‹ï¼šé¼ æ ‡æ‚¬åœåœ¨èŠ‚ç‚¹ä¸Šå¯é«˜äº®æ˜¾ç¤ºè¯¦æƒ…ã€‚
         *        ç¼–è¾‘ï¼šç‚¹å‡»å·²æœ‰äº‹ä»¶ä¼šå¼¹å‡ºæ¨¡æ€æ¡†ï¼ˆModalï¼‰ï¼Œå¯ä¿®æ”¹æ—¥æœŸã€ä¼˜å…ˆçº§ï¼ˆ0-5ï¼Œ0æœ€é«˜ï¼‰å’Œæè¿°ã€‚
         *        æ–°å¢ï¼šç‚¹å‡»è·¯å¾„ä¸Šçš„ç©ºç™½å¤„ï¼Œå¯åœ¨è¯¥æ—¶é—´ç‚¹æ·»åŠ æ–°äº‹ä»¶ã€‚
         *        åˆ é™¤ï¼šæ‚¬åœåœ¨äº‹ä»¶ä¸Šæ—¶ä¼šå‡ºç°åˆ é™¤æŒ‰é’®ï¼Œç‚¹å‡»å³å¯åˆ é™¤ã€‚
         *     è§†å›¾æ§åˆ¶ï¼š
         *        ç¼©æ”¾ï¼šæä¾›â€œ+â€å’Œâ€œ-â€æŒ‰é’®ï¼Œé€šè¿‡æ”¹å˜è·¯å¾„æ€»é•¿åº¦ï¼ˆcurrentTargetLengthï¼‰æ¥æ‹‰ä¼¸æˆ–å‹ç¼©æ—¶é—´è½´ã€‚
         *        å½“å‰æ—¶é—´æ ‡è®°ï¼šè‡ªåŠ¨è®¡ç®—å¹¶ç»˜åˆ¶â€œä»Šå¤©â€çš„æ ‡è®°ä½ç½®ã€‚
         *        æ•°æ®æŒä¹…åŒ–ï¼š
         *           ä¿å­˜ï¼šå¯ä»¥å°†å½“å‰æ‰€æœ‰äº‹ä»¶å¯¼å‡ºä¸º .txt æ–‡æœ¬æ–‡ä»¶ã€‚
         *           è¯»å–ï¼šå¯ä»¥ä¸Šä¼ ä¹‹å‰ä¿å­˜çš„ .txt æ–‡ä»¶æ¢å¤æ—¶é—´çº¿æ•°æ®ã€‚
         *  3. æŠ€æœ¯å®ç°ç»†èŠ‚
         *     ä¾èµ–åº“ï¼šä»…å¼•å…¥äº† Tailwind CSS ç”¨äº UI æ ·å¼ï¼ˆæŒ‰é’®ã€æ¨¡æ€æ¡†ï¼‰ï¼Œæ ¸å¿ƒé€»è¾‘å…¨éƒ¨ä¸ºåŸç”Ÿ JavaScriptï¼Œæ— å…¶ä»–æ¡†æ¶ä¾èµ–ã€‚
         *     ç»˜å›¾é€»è¾‘ï¼š
         *        å°†è·¯å¾„æ‹†åˆ†ä¸ºâ€œç›´çº¿â€å’Œâ€œåœ†å¼§â€ä¸¤ç§ç‰‡æ®µï¼ˆSegmentsï¼‰ã€‚
         *        é€šè¿‡ç§¯åˆ†/ç™¾åˆ†æ¯”è®¡ç®—ï¼Œå°†æ—¶é—´ï¼ˆTimeï¼‰æ˜ å°„åˆ°è·¯å¾„é•¿åº¦ï¼ˆDistanceï¼‰ï¼Œå†é€šè¿‡å‡ ä½•è®¡ç®—å¾—å‡º Canvas ä¸Šçš„ (x, y) åæ ‡å’Œåˆ‡çº¿è§’åº¦ã€‚
         *     æ•°æ®ç»“æ„ï¼š
         *        äº‹ä»¶æ•°æ®åŒ…å«æ—¶é—´æˆ³ã€ä¼˜å…ˆçº§ã€æè¿°ã€åæ ‡ä»¥åŠç”¨äºåŠ¨ç”»çš„é€æ˜åº¦/ç¼©æ”¾çŠ¶æ€ã€‚
         */

         const DEBUG = {
            ENABLED: true,
            SHOW_FPS: true,
            SHOW_COLLISION_BOXES: true
        };

        // --- é…ç½®å¸¸é‡ ---
        const CONFIG = {
            // ç»˜å›¾å¸¸é‡
            MARGIN: 60,
            TOP_MARGIN: 100,
            BOTTOM_MARGIN: 100,
            BASE_ROW_HEIGHT: 160,
            LINE_WIDTH: 6,
            LINE_COLOR: '#4a90e2',
            NODE_RADIUS: 8,
            NODE_COLOR: '#333',
            TEXT_COLOR: '#333',
            TEXT_COLOR_LIGHT: '#777',
            FONT_SIZE: 14,
            FONT_SIZE_SMALL: 10,
            DELETE_BUTTON_RADIUS: 8,
            DELETE_BUTTON_COLOR: 'rgba(255, 0, 0, 0.7)',
            HOVER_DELETE_BUTTON_COLOR: 'rgba(255, 0, 0, 1)',

            // åŠ¨ç”»é…ç½®
            ANIMATION_SPEED: 0.15,
            OPACITY_THRESHOLD: 0.01,
            SCALE_THRESHOLD: 0.01,

            // ç¼©æ”¾é…ç½®
            ZOOM_FACTOR: 1.1,

            // äº¤äº’é…ç½®
            HOVER_DELAY: 20,
            DRAG_SPEED: 0.5, // æ‹–æ‹½é€Ÿåº¦ç³»æ•°

            // ç®­å¤´é…ç½®
            ARROW_HEAD_LENGTH: 20,
            ARROW_HEAD_WIDTH: 15,
            ARROW_INDENT: 5,

            // ä»Šå¤©æ ‡è®°
            TODAY_MARKER_LENGTH: 50,

            // é¢œè‰²æ–¹æ¡ˆ
            MONTH_COLORS: [
                '#64B5F6', '#FF80AB', '#4CAF50', '#8E24AA', '#FFF176', '#2196F3',
                '#FF7043', '#66BB6A', '#FF9800', '#795548', '#FFC107', '#E53935'
            ],

            PRIORITY_COLORS: [
                '#FF0000', // 0 - ç´§æ€¥ (çº¢è‰²)
                '#FF8C00', // 1 - é«˜ (æ©™è‰²)
                '#FFD700', // 2 - ä¸­ (é‡‘è‰²)
                '#00BFFF', // 3 - ä¸€èˆ¬ (è“è‰²)
                '#9370DB', // 4 - ä½ (ç´«è‰²)
                '#808080'  // 5 - å¾…å®š (ç°è‰²)
            ],

            PRIORITY_LABELS: [
                'ğŸ”¥ ç´§æ€¥',
                'âš¡ è¾ƒé«˜',
                'â­ ä¸­ç­‰',
                'ğŸ”¹ ä¸€èˆ¬',
                'ğŸ”¸ è¾ƒä½',
                'ğŸ’¤ å¾…å®š'
            ]
        };

        const canvas = document.getElementById('timelineCanvas');
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;

        // --- æ ¸å¿ƒæ•°æ® ---
        let events = [];
        let pathSegments = [];
        let totalPathLength = 0;
        let minTime = 0;
        let maxTime = 0;
        let zoomLevel = 5;
        let currentTargetLength = 0;
        let resizeTimer;

        // åŠ¨ç”»ç›¸å…³
        let animationId;
        let isAnimating = true; // æ ‡è®°æ˜¯å¦éœ€è¦æŒç»­æ¸²æŸ“

        // æ»šåŠ¨å’Œæ‹–æ‹½ç›¸å…³
        let isDragging = false;
        let dragStartY = 0;
        let scrollTopStart = 0;
        let scrollY = 0; // å½“å‰æ»šåŠ¨ä½ç½®

        // --- æ€§èƒ½ä¼˜åŒ–ï¼šæ·»åŠ ç¼“å­˜å’Œæ ‡è®° ---
        let needsLayoutUpdate = true; // æ ‡è®°æ˜¯å¦éœ€è¦é‡æ–°è®¡ç®—å¸ƒå±€
        let cachedEventLayouts = new Map(); // ç¼“å­˜äº‹ä»¶å¸ƒå±€

        // --- äº¤äº’çŠ¶æ€ ---
        let hoveringEvent = null;
        let hoveringDeleteButton = false;
        let hoverTimer = null;

        let editingEvent = null;
        let currentMousePos = { x: 0, y: 0 };
        let editingType = 'edit';
        let hoverTarget = null;

        let frameCount = 0;
        let lastTime = performance.now();
        let fps = 0;

        // --- DOM å…ƒç´  ---
        const saveButton = document.getElementById('saveButton');
        const loadInput = document.getElementById('loadInput');
        const zoomInButton = document.getElementById('zoomInButton');
        const zoomOutButton = document.getElementById('zoomOutButton');
        const eventModal = document.getElementById('eventModal');
        const modalTitle = document.getElementById('modalTitle');
        const eventForm = document.getElementById('eventForm');
        const eventDateInput = document.getElementById('eventDate');
        const eventPriorityInput = document.getElementById('eventPriority');
        const eventDescriptionInput = document.getElementById('eventDescription');
        const cancelButton = document.getElementById('cancelButton');
        const saveEventButton = document.getElementById('saveEventButton');


        // ========================================================================
        // æ ¸å¿ƒåŠŸèƒ½: åˆå§‹åŒ–å’Œé‡ç»˜
        // ========================================================================

        function init() {
            // é¦–å…ˆè®¾ç½®åˆå§‹scrollYä¸º0ï¼Œç¡®ä¿æ—¶é—´è½´åœ¨è§†å£é¡¶éƒ¨
            scrollY = 0;

            resizeCanvas(true);

            const defaultData = `
2025-01-01 0 é¡¹ç›®å¯åŠ¨
2025-02-15 1 éœ€æ±‚åˆ†æå®Œæˆ
2025-03-01T10:00:00 5 V1.0 å‘å¸ƒ
2025-03-10 2 æ”¶é›†ç”¨æˆ·åé¦ˆ
2025-05-20T14:30:00 3 å›¢é˜Ÿå»ºè®¾
2025-07-04 1 é‡è¦é‡Œç¨‹ç¢‘
2025-09-01 5 æ–°åŠŸèƒ½A
2025-10-15 5 æ–°åŠŸèƒ½B
2025-11-11 5 æ–°åŠŸèƒ½C
2026-01-01 0 V2.0 è§„åˆ’
`;
            parseAndLoadEvents(defaultData);

            window.addEventListener('resize', resizeCanvas);

            zoomInButton.addEventListener('click', () => {
                setMostLikeTargetLength('+');
                startAnimation(); // è§¦å‘åŠ¨ç”»
            });
            zoomOutButton.addEventListener('click', () => {
                setMostLikeTargetLength('-');
                startAnimation(); // è§¦å‘åŠ¨ç”»
            });

            saveButton.addEventListener('click', saveEventsToFile);
            loadInput.addEventListener('change', loadEventsFromFile);

            canvas.addEventListener('mousemove', handleCanvasMouseMove);
            canvas.addEventListener('mousedown', handleCanvasMouseDown);
            canvas.addEventListener('mouseup', handleCanvasMouseUp);
            canvas.addEventListener('mouseleave', handleCanvasMouseLeave);
            canvas.addEventListener('wheel', handleCanvasWheel);
            canvas.addEventListener('click', handleCanvasClick);
            window.addEventListener('mousemove', handleWindowMouseMove);

            eventForm.addEventListener('submit', handleSaveEvent);
            cancelButton.addEventListener('click', closeModal);

            // ä¼˜å…ˆçº§é€‰æ‹©å™¨é¢œè‰²åŒæ­¥
            eventPriorityInput.addEventListener('change', (e) => {
                const selectedOption = e.target.options[e.target.selectedIndex];
                const color = selectedOption.dataset.color;
                if (color) {
                    e.target.style.color = color;
                }
            });

            // å¯åŠ¨åŠ¨ç”»å¾ªç¯
            animationLoop();

            // ç¡®ä¿åˆå§‹ç»˜åˆ¶
            startAnimation();
        }

        function setMostLikeTargetLength(change = '=') {
            const radius = CONFIG.BASE_ROW_HEIGHT / 2;
            const lineLength = canvas.clientWidth - CONFIG.MARGIN * 2 - radius * 2;
            const arcLength = Math.PI * radius;
            const segmentLength = lineLength + arcLength;

            // åˆå§‹åŒ–é€»è¾‘
            if (currentTargetLength === 0) {
                currentTargetLength = lineLength * 2 + arcLength;
                return;
            }

            // æ ¹æ®å½“å‰é•¿åº¦å†³å®šé‡‡ç”¨å“ªç§ç¼©æ”¾ç­–ç•¥
            if (currentTargetLength > lineLength) {
                // åŸºäºå®Œæ•´æ®µçš„ç¼©æ”¾
                let minDiff = Infinity;
                let bestLength = 0;

                // è®¡ç®—å½“å‰æœ€æ¥è¿‘çš„é•¿åº¦
                let n = 0
                let candidateLength;
                do {
                    candidateLength = lineLength + n * segmentLength;
                    const diff = Math.abs(currentTargetLength - candidateLength);
                    if (diff < minDiff) {
                        minDiff = diff;
                        bestLength = candidateLength;
                    }
                    n++;
                } while (candidateLength <= currentTargetLength);

                currentTargetLength = bestLength;

                if (change === '+') {
                    currentTargetLength += segmentLength;
                } else if (change === '-') {
                    if (currentTargetLength === lineLength) {
                        currentTargetLength = lineLength / CONFIG.ZOOM_FACTOR;
                    } else {
                        currentTargetLength -= segmentLength;
                    }
                }
            } else {
                // åŸºäºæ¯”ä¾‹çš„ç¼©æ”¾ï¼ˆé€‚ç”¨äºè¾ƒå°çš„é•¿åº¦ï¼‰
                let minDiff = Infinity;
                let bestLength = 0;

                let candidateLength = lineLength;
                while (candidateLength > lineLength * 0.5) {
                    let diff = Math.abs(currentTargetLength - candidateLength);
                    if (diff < minDiff) {
                        minDiff = diff;
                        bestLength = candidateLength;
                    }
                    candidateLength /= CONFIG.ZOOM_FACTOR;
                }

                currentTargetLength = bestLength;

                if (change === '+') {
                    if (currentTargetLength === lineLength) {
                        currentTargetLength += segmentLength;
                    } else {
                        currentTargetLength *= CONFIG.ZOOM_FACTOR;
                    }
                } else if (change === '-') {
                    currentTargetLength /= CONFIG.ZOOM_FACTOR;
                    if (currentTargetLength < lineLength * 0.5) {
                        // ç¡®ä¿é•¿åº¦è‡³å°‘ä¸ºçº¿æ®µé•¿åº¦çš„ä¸€åŠ
                        currentTargetLength *= CONFIG.ZOOM_FACTOR;
                    }
                }
            }
        }

        function createEventObject(id, dateStr, timestamp, priority, description) {
            return {
                id: id,
                dateStr: dateStr,
                timestamp: timestamp,
                priority: priority,
                description: description,
                x: 0,
                y: 0,
                bboxes: {},
                displayMode: 'hidden',
                deleteButtonPos: null,
                segmentType: 'line',
                animState: {
                    dot: {
                        opacity: 0,
                        scale: 0
                    },
                    panel: {
                        opacity: 0,
                        scale: 0
                    },
                    deleteBtn: {
                        opacity: 0,
                        scale: 0
                    }
                }
            };
        }

        function resizeCanvas(initialize = false) {
            if (resizeTimer) {
                clearTimeout(resizeTimer);
            }

            let doOnResize = () => {
                const w = window.innerWidth;
                // è®¡ç®—éœ€è¦çš„ç”»å¸ƒé«˜åº¦ä»¥å®¹çº³æ‰€æœ‰è·¯å¾„æ®µ
                let neededHeight = window.innerHeight;
                if (pathSegments.length > 0) {
                    const lastSegment = pathSegments[pathSegments.length - 1];
                    // ç¡®ä¿ç”»å¸ƒè¶³å¤Ÿé«˜ä»¥æ˜¾ç¤ºæ‰€æœ‰å†…å®¹
                    neededHeight = Math.max(neededHeight, lastSegment.y1 + CONFIG.BASE_ROW_HEIGHT);
                } else {
                    // å¦‚æœè¿˜æ²¡æœ‰è·¯å¾„æ®µï¼Œåˆ™é»˜è®¤é«˜åº¦ä¸º2
                    neededHeight = Math.max(neededHeight, 2 * CONFIG.BASE_ROW_HEIGHT);
                }

                canvas.width = w * dpr;
                canvas.height = neededHeight * dpr;
                canvas.style.width = `${w}px`;
                canvas.style.height = `${neededHeight}px`;
                ctx.scale(dpr, dpr);

                setMostLikeTargetLength();

                // æ ‡è®°éœ€è¦æ›´æ–°å¸ƒå±€è€Œä¸æ˜¯ç«‹å³è®¡ç®—
                needsLayoutUpdate = true;
                startAnimation(); // åªè¦resizeå°±è§¦å‘åŠ¨ç”»ä»¥é˜²ä¸‡ä¸€
            };

            if (initialize) {
                doOnResize();
            } else {
                resizeTimer = setTimeout(doOnResize, 100); // 100ms é˜²æŠ–åŠ¨
            }
        }

        // è§¦å‘åŠ¨ç”»æ›´æ–°
        function startAnimation() {
            isAnimating = true;
            needsLayoutUpdate = true; // æ ‡è®°éœ€è¦æ›´æ–°å¸ƒå±€
        }

        function animationLoop() {
            const now = performance.now();
            frameCount++;
            if (now - lastTime >= 1000) {
                fps = Math.round((frameCount * 1000) / (now - lastTime));
                frameCount = 0;
                lastTime = now;
            }

            let hasChanges = false;

            // 1. é€»è¾‘æ›´æ–° (Lerp)
            hasChanges = updateAnimations();

            // 2. å¦‚æœæœ‰å˜åŒ–æˆ–éœ€è¦å¸ƒå±€æ›´æ–°ï¼Œåˆ™é‡æ–°è®¡ç®—å’Œç»˜åˆ¶
            if (hasChanges || needsLayoutUpdate || isAnimating) {
                calculatePathSegments();
                draw();
                needsLayoutUpdate = false;

                if (!hasChanges && !needsLayoutUpdate) {
                    isAnimating = false; // åœæ­¢åŠ¨ç”»
                }
            }

            requestAnimationFrame(animationLoop);
        }

        // ä¿®æ”¹ updateAnimations å‡½æ•°ä»¥è¿”å›æ˜¯å¦æœ‰å˜åŒ–
        function updateAnimations() {
            const speed = CONFIG.ANIMATION_SPEED;
            let hasChanges = false;

            // å¦‚æœæ­£åœ¨ç¼©æ”¾è·¯å¾„
            // (è¿™é‡Œå¯ä»¥æ˜¯æ›´å¤æ‚çš„è·¯å¾„åŠ¨ç”»ï¼Œæš‚ä¸”è·³è¿‡ï¼Œä¸“æ³¨äºäº‹ä»¶é€æ˜åº¦)

            events.forEach(event => {
                let target = {
                    dot: {
                        opacity: 0,
                        scale: 0
                    },
                    panel: {
                        opacity: 0,
                        scale: 0
                    },
                    deleteBtn: {
                        opacity: 0,
                        scale: 0
                    }
                }

                if (event.displayMode === 'full') {
                    target.dot.opacity = 1;
                    target.dot.scale = 1;
                    target.panel.opacity = 1;
                    target.panel.scale = 1;
                } else if (event.displayMode === 'dot') {
                    target.dot.opacity = 1;
                    target.dot.scale = 0.5;
                }

                if (event == hoveringEvent) {
                    target.dot.opacity = 1;
                    target.dot.scale = 1.1;
                    target.panel.opacity = 1;
                    target.panel.scale = 1.1;
                    target.deleteBtn.opacity = 1;
                    target.deleteBtn.scale = 1.1;
                }

                // Lerp
                if (Math.abs(target.dot.opacity - event.animState.dot.opacity) > CONFIG.SCALE_THRESHOLD) {
                    event.animState.dot.opacity += (target.dot.opacity - event.animState.dot.opacity) * speed;
                    hasChanges = true;
                } else {
                    if (event.animState.dot.opacity !== target.dot.opacity) {
                        event.animState.dot.opacity = target.dot.opacity;
                        hasChanges = true;
                    }
                }
                if (Math.abs(target.dot.scale - event.animState.dot.scale) > CONFIG.SCALE_THRESHOLD) {
                    event.animState.dot.scale += (target.dot.scale - event.animState.dot.scale) * speed;
                    hasChanges = true;
                } else {
                    if (event.animState.dot.scale !== target.dot.scale) {
                        event.animState.dot.scale = target.dot.scale;
                        hasChanges = true;
                    }
                }

                if (Math.abs(target.panel.opacity - event.animState.panel.opacity) > CONFIG.SCALE_THRESHOLD) {
                    event.animState.panel.opacity += (target.panel.opacity - event.animState.panel.opacity) * speed;
                    hasChanges = true;
                } else {
                    if (event.animState.panel.opacity !== target.panel.opacity) {
                        event.animState.panel.opacity = target.panel.opacity;
                        hasChanges = true;
                    }
                }
                if (Math.abs(target.panel.scale - event.animState.panel.scale) > CONFIG.SCALE_THRESHOLD) {
                    event.animState.panel.scale += (target.panel.scale - event.animState.panel.scale) * speed;
                    hasChanges = true;
                } else {
                    if (event.animState.panel.scale !== target.panel.scale) {
                        event.animState.panel.scale = target.panel.scale;
                        hasChanges = true;
                    }
                }

                if (Math.abs(target.deleteBtn.opacity - event.animState.deleteBtn.opacity) > CONFIG.SCALE_THRESHOLD) {
                    event.animState.deleteBtn.opacity += (target.deleteBtn.opacity - event.animState.deleteBtn.opacity) * speed;
                    hasChanges = true;
                } else {
                    if (event.animState.deleteBtn.opacity !== target.deleteBtn.opacity) {
                        event.animState.deleteBtn.opacity = target.deleteBtn.opacity;
                        hasChanges = true;
                    }
                }
                if (Math.abs(target.deleteBtn.scale - event.animState.deleteBtn.scale) > CONFIG.SCALE_THRESHOLD) {
                    event.animState.deleteBtn.scale += (target.deleteBtn.scale - event.animState.deleteBtn.scale) * speed;
                    hasChanges = true;
                } else {
                    if (event.animState.deleteBtn.scale !== target.deleteBtn.scale) {
                        event.animState.deleteBtn.scale = target.deleteBtn.scale;
                        hasChanges = true;
                    }
                }
            });

            return hasChanges;
        }

        function calculatePathSegments() {
            const w = canvas.clientWidth;
            const h = canvas.clientHeight;

            pathSegments = [];
            totalPathLength = 0;

            const radius = CONFIG.BASE_ROW_HEIGHT / 2;
            const lineStartX = CONFIG.MARGIN + radius;
            const lineEndX = w - CONFIG.MARGIN - radius;
            const lineLength = lineEndX - lineStartX;
            const arcLength = Math.PI * radius;

            if (lineLength <= 0) return;

            setMostLikeTargetLength();

            const lengthPerRow = lineLength + arcLength;
            const numRows = (lengthPerRow > 0) ? Math.ceil(currentTargetLength / lengthPerRow) : 1;

            // ç®€åŒ–èµ·å§‹Yåæ ‡è®¡ç®—ï¼Œç›´æ¥ä½¿ç”¨TOP_MARGIN
            const startY = CONFIG.TOP_MARGIN + radius;

            let y = startY;
            let direction = 1;

            // å…è®¸è·¯å¾„æ— é™å»¶ä¼¸ï¼Œä¸å†å—ç”»å¸ƒåº•éƒ¨é™åˆ¶
            while (totalPathLength < currentTargetLength) {
                const remainingLength = currentTargetLength - totalPathLength;

                const lineDrawLength = Math.min(lineLength, remainingLength);
                if (lineDrawLength <= 0) break;

                let startX, endX;
                if (direction > 0) {
                    startX = lineStartX;
                    endX = lineStartX + lineDrawLength;
                } else {
                    startX = lineEndX;
                    endX = lineEndX - lineDrawLength;
                }

                pathSegments.push({
                    type: 'line',
                    x1: startX, y1: y,
                    x2: endX, y2: y,
                    length: lineDrawLength,
                    startLength: totalPathLength
                });
                totalPathLength += lineDrawLength;

                if (totalPathLength >= currentTargetLength) break;

                const arcRemainingLength = currentTargetLength - totalPathLength;
                const arcDrawLength = Math.min(arcLength, arcRemainingLength);
                if (arcDrawLength <= 0) break;

                let arcCenter, startAngle, endAngle, anticlockwise;
                const anglePercent = arcDrawLength / arcLength;

                if (direction > 0) {
                    arcCenter = [w - CONFIG.MARGIN - radius, y + radius];
                    startAngle = -Math.PI / 2;
                    endAngle = startAngle + (Math.PI * anglePercent);
                    anticlockwise = false;
                } else {
                    arcCenter = [CONFIG.MARGIN + radius, y + radius];
                    startAngle = -Math.PI / 2;
                    endAngle = startAngle - (Math.PI * anglePercent);
                    anticlockwise = true;
                }

                pathSegments.push({
                    type: 'arc',
                    cx: arcCenter[0], cy: arcCenter[1],
                    radius: radius,
                    startAngle: startAngle,
                    endAngle: endAngle,
                    anticlockwise: anticlockwise,
                    length: arcDrawLength,
                    startLength: totalPathLength
                });
                totalPathLength += arcDrawLength;

                if (totalPathLength >= currentTargetLength) break;

                y += CONFIG.BASE_ROW_HEIGHT;
                direction *= -1;
            }
        }

        // ========================================================================
        // ç»˜å›¾
        // ========================================================================

        function draw() {
            ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr);

            // åº”ç”¨æ»šåŠ¨å˜æ¢
            ctx.save();
            ctx.translate(0, -scrollY);

            drawTimelinePath();

            // 1. å¸ƒå±€è®¡ç®— (æ¯ä¸€å¸§éƒ½é‡æ–°è®¡ç®—ï¼Œå› ä¸ºçº¿é•¿å¯èƒ½åœ¨å˜)
            processEventsLayout();

            // 2. ç»˜åˆ¶"ä»Šå¤©"
            drawTodayMarker();

            // 3. ç»˜åˆ¶æ‚¬åœæŒ‡ç¤ºå™¨
            drawTimelineHoverIndicator();

            // 4. ç»˜åˆ¶äº‹ä»¶ (ä½¿ç”¨åŠ¨ç”»å±æ€§æ¸²æŸ“)
            renderEvents();

            ctx.restore();

            // 5. è°ƒè¯•ä¿¡æ¯
            if (DEBUG.ENABLED && DEBUG.SHOW_FPS) {
                ctx.save();
                ctx.font = '12px Arial';
                ctx.fillStyle = 'red';
                ctx.fillText(`FPS: ${fps}`, 10, 20);
                ctx.fillText(`Events: ${events.length}`, 10, 35);
                ctx.fillText(`Path Segments: ${pathSegments.length}`, 10, 50);
                ctx.fillText(`ScrollY: ${scrollY.toFixed(2)}`, 10, 65);
                ctx.fillText(`Canvas H: ${canvas.clientHeight}`, 10, 80);
                ctx.restore();
            }
        }

        function drawTimelinePath() {
            ctx.save();
            ctx.lineWidth = CONFIG.LINE_WIDTH;
            ctx.lineCap = 'round';

            if (minTime >= maxTime || totalPathLength === 0) {
                ctx.beginPath();
                ctx.strokeStyle = CONFIG.LINE_COLOR;
                for (const segment of pathSegments) {
                    if (segment.type === 'line') {
                        ctx.moveTo(segment.x1, segment.y1);
                        ctx.lineTo(segment.x2, segment.y2);
                    } else if (segment.type === 'arc') {
                        ctx.arc(segment.cx, segment.cy, segment.radius, segment.startAngle, segment.endAngle, segment.anticlockwise);
                    }
                }
                ctx.stroke();
                drawEndArrow(CONFIG.LINE_COLOR);
                ctx.restore();
                return;
            }

            const startDate = new Date(minTime);
            let currentDate = new Date(startDate.getFullYear(), startDate.getMonth(), 1);

            while (currentDate.getTime() < maxTime) {
                const month = currentDate.getMonth();
                const color = CONFIG.MONTH_COLORS[month];

                const startTime = Math.max(currentDate.getTime(), minTime);
                let nextMonth = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 1);
                const endTime = Math.min(nextMonth.getTime(), maxTime);

                drawPathSegmentForTimeRange(startTime, endTime, color);

                currentDate = nextMonth;
                if (endTime === maxTime) break;
            }

            if (pathSegments.length > 0) {
                const lastDate = new Date(maxTime);
                const arrowColor = CONFIG.MONTH_COLORS[lastDate.getMonth()] || CONFIG.LINE_COLOR;
                drawEndArrow(arrowColor);
            }

            ctx.restore();
        }

        function drawPathSegmentForTimeRange(startTime, endTime, color) {
            if (startTime >= endTime) return;
            const timeRange = maxTime - minTime;
            if (timeRange <= 0) return;

            const startPercent = (startTime - minTime) / timeRange;
            const endPercent = (endTime - minTime) / timeRange;

            const startDist = startPercent * totalPathLength;
            const endDist = endPercent * totalPathLength;

            if (startDist >= endDist) return;

            ctx.strokeStyle = color;

            for (const segment of pathSegments) {
                const segStart = segment.startLength;
                const segEnd = segStart + segment.length;

                const drawStart = Math.max(startDist, segStart);
                const drawEnd = Math.min(endDist, segEnd);

                if (drawStart < drawEnd && (drawEnd - drawStart > 0.001)) {
                    ctx.beginPath();

                    if (segment.length <= 0) continue;

                    let percentStart = (drawStart - segStart) / segment.length;
                    let percentEnd = (drawEnd - segStart) / segment.length;
                    percentStart = Math.max(0, Math.min(1, percentStart));
                    percentEnd = Math.max(0, Math.min(1, percentEnd));

                    if (segment.type === 'line') {
                        const x1 = segment.x1 + (segment.x2 - segment.x1) * percentStart;
                        const y1 = segment.y1;
                        const x2 = segment.x1 + (segment.x2 - segment.x1) * percentEnd;
                        const y2 = segment.y1;
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                    } else if (segment.type === 'arc') {
                        const angleStart = segment.startAngle + (segment.endAngle - segment.startAngle) * percentStart;
                        const angleEnd = segment.startAngle + (segment.endAngle - segment.startAngle) * percentEnd;
                        if (Math.abs(angleStart - angleEnd) > 0.0001) {
                            ctx.arc(segment.cx, segment.cy, segment.radius, angleStart, angleEnd, segment.anticlockwise);
                        }
                    }
                    ctx.stroke();
                }
            }
        }

        function drawEndArrow(color) {
            if (pathSegments.length === 0) return;
            const lastSeg = pathSegments[pathSegments.length - 1];
            let x, y, angle;

            if (lastSeg.type === 'line') {
                x = lastSeg.x2;
                y = lastSeg.y2;
                angle = (lastSeg.x2 > lastSeg.x1) ? 0 : Math.PI;
            } else {
                x = lastSeg.cx + lastSeg.radius * Math.cos(lastSeg.endAngle);
                y = lastSeg.cy + lastSeg.radius * Math.sin(lastSeg.endAngle);
                angle = lastSeg.endAngle + (lastSeg.anticlockwise ? -Math.PI/2 : Math.PI/2);
            }

            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-CONFIG.ARROW_INDENT, CONFIG.ARROW_HEAD_WIDTH / 2);
            ctx.lineTo(CONFIG.ARROW_HEAD_LENGTH, 0);
            ctx.lineTo(-CONFIG.ARROW_INDENT, -CONFIG.ARROW_HEAD_WIDTH / 2);
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
            ctx.restore();
        }

        function drawTodayMarker() {
            const todayTimestamp = new Date().getTime();
            if (todayTimestamp < minTime || todayTimestamp > maxTime || totalPathLength === 0) return;
            const timeRange = maxTime - minTime;
            if (timeRange <= 0) return;
            const timePercent = (todayTimestamp - minTime) / timeRange;
            const distance = timePercent * totalPathLength;
            const coords = getCoordsAtDistance(distance);
            if (!coords) return;

            // ç»˜åˆ¶å‚ç›´è™šçº¿ï¼Œåªåœ¨æ—¶é—´è½´ä¸Šä¸‹å„å»¶ä¼¸ CONFIG.TODAY_MARKER_LENGTH
            ctx.save();

            ctx.beginPath();
            ctx.setLineDash([3, 3]); // è®¾ç½®è™šçº¿æ ·å¼
            ctx.lineWidth = 1;
            ctx.strokeStyle = '#FF0000'; // çº¢è‰²

            // æ ¹æ®è·¯å¾„åˆ‡çº¿è§’åº¦è®¡ç®—å‚ç›´æ–¹å‘
            const angle = coords.angle;
            const perpAngle = angle + Math.PI / 2; // å‚ç›´äºè·¯å¾„çš„æ–¹å‘

            // è®¡ç®—çº¿æ®µçš„èµ·ç‚¹å’Œç»ˆç‚¹
            const startX = coords.x + Math.cos(perpAngle) * CONFIG.TODAY_MARKER_LENGTH;
            const startY = coords.y + Math.sin(perpAngle) * CONFIG.TODAY_MARKER_LENGTH;
            const endX = coords.x - Math.cos(perpAngle) * CONFIG.TODAY_MARKER_LENGTH;
            const endY = coords.y - Math.sin(perpAngle) * CONFIG.TODAY_MARKER_LENGTH;

            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();

            ctx.restore();
        }

        function drawTimelineHoverIndicator() {
            if (!hoverTarget) return;
            if (!currentMousePos) return;
            if (hoverTarget.type !== 'path') return;

            // ä½¿ç”¨å½“å‰é¼ æ ‡ä½ç½®ï¼ˆæ— éœ€æ‰‹åŠ¨è°ƒæ•´ï¼Œå·²ç”±å¤–å±‚translateå¤„ç†ï¼‰
            const currentTime = getTimeAtCoords(currentMousePos.x, currentMousePos.y);
            const timePercent = (currentTime - minTime) / (maxTime - minTime);
            const distance = timePercent * totalPathLength;
            const coords = getCoordsAtDistance(distance);
            if (!coords) return;

            // ç»˜åˆ¶æ‚¬åœæŒ‡ç¤ºå™¨ï¼ˆå°åœ†åœˆï¼‰
            ctx.save();
            ctx.beginPath();
            ctx.strokeStyle = 'rgb(255, 0, 0)';
            ctx.lineWidth = 1;
            ctx.arc(coords.x, coords.y, CONFIG.LINE_WIDTH, 0, 2 * Math.PI);
            ctx.stroke();
            ctx.arc(coords.x, coords.y, CONFIG.LINE_WIDTH - 2, 0, 2 * Math.PI);
            ctx.stroke();
            ctx.arc(coords.x, coords.y, CONFIG.LINE_WIDTH - 4, 0, 2 * Math.PI);
            ctx.stroke();
            ctx.restore();
        }

        // ========================================================================
        // ç»˜åˆ¶äº‹ä»¶ (ç¢°æ’æ£€æµ‹ + æ™ºèƒ½å¸ƒå±€)
        // ========================================================================

        function processEventsLayout() {
            if (minTime >= maxTime || totalPathLength === 0) return;

            // æ£€æŸ¥æ˜¯å¦å¯ä»¥ä»ç¼“å­˜ä¸­è·å–å¸ƒå±€
            const cacheKey = `${minTime}-${maxTime}-${totalPathLength}-${events.length}`;
            if (cachedEventLayouts.has(cacheKey) && !needsLayoutUpdate) {
                // ä½¿ç”¨ç¼“å­˜çš„å¸ƒå±€
                const cachedLayout = cachedEventLayouts.get(cacheKey);
                events.forEach((event, index) => {
                    const animState = event.animState;
                    Object.assign(event, cachedLayout[index]);
                    event.animState = animState;
                });
                return;
            }

            let drawnRects = [];

            // 1. åŸºç¡€è®¡ç®—
            events.forEach((event, index) => {
                updateEventCoordinates(event);
                event.timeIndex = index;
                event.displayMode = 'hidden';
                calculateEventBBoxes(event, index % 2 === 0);
            });

            // 2. æ™ºèƒ½å¸ƒå±€
            const sortedEvents = [...events].sort((a, b) => a.priority - b.priority);

            for (const event of sortedEvents) {
                const preferredIsAbove = (event.timeIndex % 2 === 0);

                calculateEventBBoxes(event, preferredIsAbove);
                let potRect = event.bboxes.background;
                let isColliding = drawnRects.some(rect => isOverlapping(rect, potRect));

                if (isColliding) {
                    calculateEventBBoxes(event, !preferredIsAbove);
                    potRect = event.bboxes.background;
                    isColliding = drawnRects.some(rect => isOverlapping(rect, potRect));
                }

                if (isColliding) {
                    event.displayMode = 'dot';
                    calculateEventBBoxes(event, preferredIsAbove);
                } else {
                    event.displayMode = 'full';
                    drawnRects.push(potRect);
                }
            }

            // ç¼“å­˜å¸ƒå±€ç»“æœ
            cachedEventLayouts.set(cacheKey, JSON.parse(JSON.stringify(events)));
            needsLayoutUpdate = false; // é‡ç½®æ ‡è®°
        }

        function renderEvents() {
            if (minTime >= maxTime || totalPathLength === 0) return;

            // å±‚çº§ 1: éæ‚¬åœ
            for (const event of events) {
                if (hoveringEvent === event) continue;
                drawAnimatedEvent(event);
            }

            // å±‚çº§ 2: æ‚¬åœ
            if (hoveringEvent) {
                drawAnimatedEvent(hoveringEvent);
            }
        }

        /**
         * (æ–°å¢) é€šç”¨ç»˜åˆ¶å‡½æ•°ï¼Œå¤„ç†é€æ˜åº¦å’Œç¼©æ”¾
         */
        function drawAnimatedEvent(event) {
            drawNode(event);
            drawEventPanel(event);

            // åªæœ‰åœ¨å®Œå…¨æ‚¬åœä¸”ä¸é€æ˜æ—¶æ˜¾ç¤ºåˆ é™¤æŒ‰é’®
            if (hoveringEvent === event) {
                drawDeleteButton(event);
            }
            // ç§»é™¤äº†æ­¤å¤„çš„ ctx.restore()ï¼Œå› ä¸ºå®ƒä¸å¤–å±‚çš„ save/restore ä¸åŒ¹é…
        }

        function updateEventCoordinates(event) {
            if (minTime >= maxTime || totalPathLength === 0) return;
            const timeRange = maxTime - minTime;
            if (timeRange <= 0) return;
            const timePercent = (event.timestamp - minTime) / timeRange;
            const distance = timePercent * totalPathLength;
            const coords = getCoordsAtDistance(distance);

            if (coords) {
                event.x = coords.x;
                event.y = coords.y;
                event.angle = coords.angle;
                event.segmentType = coords.segmentType;
            } else {
                event.x = 0;
                event.y = 0;
                event.segmentType = 'line';
            }
        }

        function isOverlapping(rect1, rect2) {
            if (!rect1 || !rect2) return false;
            return !(
                rect1.x + rect1.w < rect2.x ||
                rect2.x + rect2.w < rect1.x ||
                rect1.y + rect1.h < rect2.y ||
                rect2.y + rect2.h < rect1.y
            );
        }

        function drawNode(event) {
            if (event.animState.dot.opacity < CONFIG.OPACITY_THRESHOLD) return;
            ctx.save();
            ctx.globalAlpha = event.animState.dot.opacity;
            // è®¾ç½®å˜æ¢ä¸­å¿ƒä¸ºèŠ‚ç‚¹ä½ç½®ï¼Œè€ƒè™‘æ»šåŠ¨åç§»é‡
            ctx.translate(event.x, event.y);
            ctx.scale(event.animState.dot.scale, event.animState.dot.scale);
            ctx.translate(-event.x, -event.y);

            if (hoveringEvent === event) {
                ctx.shadowColor = CONFIG.PRIORITY_COLORS[event.priority];
                ctx.shadowBlur = CONFIG.NODE_RADIUS + 5;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
            }

            ctx.beginPath();
            ctx.fillStyle = '#FFFFFF';
            ctx.arc(event.x, event.y, CONFIG.NODE_RADIUS + 1, 0, 2 * Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.fillStyle = CONFIG.NODE_COLOR;
            ctx.arc(event.x, event.y, CONFIG.NODE_RADIUS, 0, 2 * Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.fillStyle = CONFIG.PRIORITY_COLORS[event.priority];
            ctx.arc(event.x, event.y, CONFIG.NODE_RADIUS - 1, 0, 2 * Math.PI);
            ctx.fill();
            ctx.restore();
        }

        function drawEventPanel(event) {
            if (event.animState.panel.opacity < CONFIG.OPACITY_THRESHOLD) return;
            const bgBox = event.bboxes.background;
            if (!bgBox) return;
            ctx.save();
            ctx.globalAlpha = event.animState.panel.opacity;
            // è®¾ç½®å˜æ¢ä¸­å¿ƒä¸ºèŠ‚ç‚¹ä½ç½®ï¼Œè€ƒè™‘æ»šåŠ¨åç§»é‡
            ctx.translate(event.x, event.y);
            ctx.scale(event.animState.panel.scale, event.animState.panel.scale);
            ctx.translate(-event.x, -event.y);

            ctx.beginPath();
            const collisionPadding = 4;
            if (ctx.roundRect) {
                const x = bgBox.x + collisionPadding;
                const y = bgBox.y + collisionPadding;
                const w = bgBox.w - collisionPadding * 2;
                const h = bgBox.h - collisionPadding * 2;
                ctx.roundRect(x, y, w, h, 10);
            } else {
                ctx.rect(bgBox.x, bgBox.y, bgBox.w, bgBox.h);
            }
            ctx.clip();

            ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
            ctx.fillRect(bgBox.x, bgBox.y, bgBox.w, bgBox.h);

            // åœ¨åœ†è§’çŸ©å½¢å†…éƒ¨ç»˜åˆ¶5pxå®½çš„ä¼˜å…ˆçº§é¢œè‰²æ¡
            // ctx.fillStyle = CONFIG.PRIORITY_COLORS[event.priority] || CONFIG.PRIORITY_COLORS[5];
            // ctx.fillRect(bgBox.x, bgBox.y, collisionPadding + 5, bgBox.h);

            const descBox = event.bboxes.description;
            const dateBox = event.bboxes.date;
            if (!descBox || !dateBox) return;
            ctx.fillStyle = CONFIG.TEXT_COLOR;
            ctx.font = `bold ${CONFIG.FONT_SIZE}px Inter`;
            ctx.fillText(descBox.text, descBox.x, descBox.y + descBox.h);
            ctx.fillStyle = CONFIG.TEXT_COLOR_LIGHT;
            ctx.font = `${CONFIG.FONT_SIZE_SMALL}px Inter`;
            ctx.fillText(dateBox.text, dateBox.x, dateBox.y + dateBox.h);

            ctx.restore();
        }

        function drawDeleteButton(event) {
            if (event.animState.deleteBtn.opacity < CONFIG.OPACITY_THRESHOLD) return;
            const isHovering = (hoveringEvent === event);
            if (!isHovering) return; // åªåœ¨æ‚¬åœæ—¶æ˜¾ç¤ºåˆ é™¤æŒ‰é’®
            if (!event.bboxes || !event.bboxes.background) return;
            const bgBox = event.bboxes.background;
            const deleteBtnX = bgBox.x + bgBox.w - 4;
            const deleteBtnY = bgBox.y + 4;

            const deleteBtnPos = { x: deleteBtnX, y: deleteBtnY };
            event.deleteButtonPos = deleteBtnPos;

            ctx.save();
            ctx.globalAlpha = event.animState.deleteBtn.opacity;
            // åº”ç”¨ç¼©æ”¾å˜æ¢
            ctx.translate(deleteBtnPos.x, deleteBtnPos.y);
            ctx.scale(event.animState.deleteBtn.scale, event.animState.deleteBtn.scale);
            ctx.translate(-deleteBtnPos.x, -deleteBtnPos.y);

            ctx.beginPath();
            ctx.fillStyle = (hoveringDeleteButton && isHovering) ? CONFIG.HOVER_DELETE_BUTTON_COLOR : CONFIG.DELETE_BUTTON_COLOR;
            // ç»˜åˆ¶åœ†åœˆæ—¶è€ƒè™‘æ»šåŠ¨åç§»
            ctx.arc(deleteBtnPos.x, deleteBtnPos.y - scrollY, CONFIG.DELETE_BUTTON_RADIUS, 0, 2 * Math.PI);
            ctx.fill();

            ctx.strokeStyle = 'white';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            const xOff = CONFIG.DELETE_BUTTON_RADIUS * 0.4;
            // ç»˜åˆ¶å‰å·æ—¶è€ƒè™‘æ»šåŠ¨åç§»
            ctx.moveTo(deleteBtnPos.x - xOff, deleteBtnPos.y - scrollY - xOff);
            ctx.lineTo(deleteBtnPos.x + xOff, deleteBtnPos.y - scrollY + xOff);
            ctx.moveTo(deleteBtnPos.x + xOff, deleteBtnPos.y - scrollY - xOff);
            ctx.lineTo(deleteBtnPos.x - xOff, deleteBtnPos.y - scrollY + xOff);
            ctx.stroke();

            ctx.restore();
        }

        function calculateEventBBoxes(event, isAbove) {
            let xOffset = 0;
            if (event.segmentType === 'arc') {
                const nodeXFraction = (event.x - CONFIG.MARGIN) / (canvas.clientWidth - CONFIG.MARGIN * 2);
                if (nodeXFraction < 0.1) {
                    xOffset = 20;
                } else if (nodeXFraction > 0.9) {
                    xOffset = -20;
                }
            }

            const x = event.x + xOffset;
            event.bboxes = {};
            let maxTextWidth = -Infinity;
            let minTextX = Infinity;

            ctx.font = `bold ${CONFIG.FONT_SIZE}px Inter`;
            const descText = event.description;
            const descMetrics = ctx.measureText(descText);

            ctx.font = `${CONFIG.FONT_SIZE_SMALL}px Inter`;
            const dateText = (event.dateStr.includes('T') ? event.dateStr.replace('T', ' ') : event.dateStr);
            const dateMetrics = ctx.measureText(dateText);

            let yDesc, yDate;
            const gap = 12;

            // ç¡®ä¿ä¸Šä¸‹æ–¹äº‹ä»¶ä¸æ—¶é—´è½´çš„è·ç¦»ä¸€è‡´
            if (isAbove) {
                const bottomY = event.y - CONFIG.NODE_RADIUS - gap;
                yDate = bottomY - CONFIG.FONT_SIZE_SMALL;
                yDesc = yDate - 4 - CONFIG.FONT_SIZE;
            } else {
                const topY = event.y + CONFIG.NODE_RADIUS + gap;
                yDesc = topY + CONFIG.FONT_SIZE;
                yDate = yDesc + 4 + CONFIG.FONT_SIZE_SMALL;
            }

            const xDesc = x - descMetrics.width / 2;
            event.bboxes.description = {
                x: xDesc,
                y: isAbove ? yDesc : yDesc - CONFIG.FONT_SIZE,
                w: descMetrics.width,
                h: CONFIG.FONT_SIZE,
                text: descText
            };
            maxTextWidth = Math.max(maxTextWidth, xDesc + descMetrics.width);
            minTextX = Math.min(minTextX, xDesc);

            const xDate = x - dateMetrics.width / 2;
            event.bboxes.date = {
                x: xDate,
                y: isAbove ? yDate : yDate - CONFIG.FONT_SIZE_SMALL,
                w: dateMetrics.width,
                h: CONFIG.FONT_SIZE_SMALL,
                text: dateText
            };
            maxTextWidth = Math.max(maxTextWidth, xDate + dateMetrics.width);
            minTextX = Math.min(minTextX, xDate);

            event.maxTextX = maxTextWidth;
            event.minTextX = minTextX;

            const padding = 8;
            const bgX = event.minTextX - padding;
            const bgY = event.bboxes.description.y - padding;
            const bgW = (event.maxTextX - event.minTextX) + padding * 2;
            const bottomTextY = Math.max(event.bboxes.description.y + event.bboxes.description.h, event.bboxes.date.y + event.bboxes.date.h);
            const bgH = (bottomTextY - bgY) + padding;

            const collisionPadding = 4;
            event.bboxes.background = {
                x: bgX - collisionPadding,
                y: bgY - collisionPadding,
                w: bgW + collisionPadding * 2,
                h: bgH + collisionPadding * 2
            };
        }

        // ========================================================================
        // åæ ‡è®¡ç®—
        // ========================================================================

        function getCoordsAtDistance(distance) {
            if (typeof distance !== 'number' || isNaN(distance)) {
                return null;
            }
            let segment = null;
            for (let i = pathSegments.length - 1;i >= 0;i--) {
                if (distance >= pathSegments[i].startLength) {
                    segment = pathSegments[i];
                    break;
                }
            }
            if (!segment) {
                if (pathSegments.length > 0) {
                    const firstSeg = pathSegments[0];
                    if (firstSeg.type === 'line') {
                        return { x: firstSeg.x1, y: firstSeg.y1, angle: (firstSeg.x2 > firstSeg.x1) ? 0 : Math.PI, segmentType: 'line' };
                    } else if (firstSeg.type === 'arc') {
                        const angle = firstSeg.startAngle;
                        const x = firstSeg.cx + firstSeg.radius * Math.cos(angle);
                        const y = firstSeg.cy + firstSeg.radius * Math.sin(angle);
                        return { x: x, y: y, angle: angle + (Math.PI / 2), segmentType: 'arc' };
                    }
                }
                return null;
            }

            const distanceInSegment = distance - segment.startLength;

            if (segment.type === 'line') {
                const percent = (segment.length === 0) ? 0 : (distanceInSegment / segment.length);
                const clampedPercent = Math.max(0, Math.min(1, percent));
                const x = segment.x1 + (segment.x2 - segment.x1) * clampedPercent;
                const y = segment.y1;
                const angle = (segment.x2 > segment.x1) ? 0 : Math.PI;
                return { x, y, angle, segmentType: 'line' };

            } else if (segment.type === 'arc') {
                const anglePercent = (segment.length === 0) ? 0 : (distanceInSegment / segment.length);
                const clampedPercent = Math.max(0, Math.min(1, anglePercent));
                const angle = segment.startAngle + (segment.endAngle - segment.startAngle) * clampedPercent;

                const x = segment.cx + segment.radius * Math.cos(angle);
                const y = segment.cy + segment.radius * Math.sin(angle);

                let tangentAngle = angle + (Math.PI / 2);
                if (segment.anticlockwise) {
                     tangentAngle = angle - (Math.PI / 2);
                }
                return { x, y, angle: tangentAngle, segmentType: 'arc' };
            }
            return null;
        }

        function getTimeAtCoords(x, y) {
            // è€ƒè™‘æ»šåŠ¨åç§»é‡
            const adjustedY = y + scrollY;

            let minDistance = Infinity, bestDistance = 0;
            for (let d = 0; d < totalPathLength; d += CONFIG.LINE_WIDTH) {
                const pt = getCoordsAtDistance(d);
                const dist = (pt.x - x) ** 2 + (pt.y - adjustedY) ** 2;
                if (dist < minDistance) {
                    minDistance = dist;
                    bestDistance = d;
                }
            }

            if (minDistance < CONFIG.LINE_WIDTH ** 4) {
                return minTime + (maxTime - minTime) * (bestDistance / totalPathLength);
            }
            return null;
        }

        // ========================================================================
        // æ•°æ®å¤„ç† / äº¤äº’
        // ========================================================================

        function parseAndLoadEvents(data) {
            try {
                events = [];
                const lines = data.split('\n').filter(line => line.trim() !== '');
                if (lines.length === 0) {
                    const thisYear = new Date();
                    thisYear = new Date().setMonth(0, 1)
                    minTime = thisYear.getTime();
                    maxTime = new Date(thisYear.getFullYear() + 1, 0, 1).getTime();
                    resizeCanvas();
                    return;
                }
                let tempMin = Infinity;
                let tempMax = -Infinity;

                lines.forEach((line, index) => {
                    try{
                        const parts = line.trim().split(' ');
                        if (parts.length < 3) return;
                        const dateTime = parts[0];
                        const priority = Math.min(5, parseInt(parts[1], 10));
                        const description = parts.slice(2).join(' ');
                        const timestamp = new Date(dateTime.includes('T') ? dateTime : dateTime.replace(' ', 'T')).getTime();
                        if (isNaN(timestamp)) return;

                        if (timestamp < tempMin) tempMin = timestamp;
                        if (timestamp > tempMax) tempMax = timestamp;

                        events.push(createEventObject(
                            `evt_${index}`,
                            dateTime,
                            timestamp,
                            priority,
                            description
                        ));
                    } catch(e){
                        console.error('è§£æäº‹ä»¶è¡Œæ—¶å‡ºé”™ï¼š', line, e);
                    }
                });

                if (tempMin === Infinity) {
                    minTime = new Date().getTime();
                    maxTime = minTime + 86400000;
                } else {
                    const padding = (tempMax - tempMin) * 0.05 || 86400000;
                    minTime = tempMin - padding;
                    maxTime = tempMax + padding;
                }
                events.sort((a, b) => a.timestamp - b.timestamp);
                resizeCanvas();
                // ç¡®ä¿åˆå§‹åŠ¨ç”»
                startAnimation();

                // æ•°æ®åŠ è½½å®Œæˆåï¼Œç¡®ä¿scrollYä¸º0
                scrollY = 0;
            } catch (e) {
                console.error('è§£æäº‹ä»¶æ•°æ®æ—¶å‡ºé”™ï¼š', e);
                const thisYear = new Date();
                thisYear = new Date().setMonth(0, 1)
                minTime = thisYear.getTime();
                maxTime = new Date(thisYear.getFullYear() + 1, 0, 1).getTime();
                resizeCanvas();
            }
        }

        function formatEventsToString() {
            return events.sort((a, b) => a.timestamp - b.timestamp).map(e => `${(e.dateStr.includes('T') ? e.dateStr : e.dateStr.replace(' ', 'T'))} ${e.priority} ${e.description}`).join('\n');
        }

        function saveEventsToFile() {
            const data = formatEventsToString();
            const blob = new Blob([data], { type: 'text/plain' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'timeline_events.txt';
            a.click();
            URL.revokeObjectURL(a.href);
        }

        function loadEventsFromFile(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => { parseAndLoadEvents(e.target.result);};
                reader.readAsText(file);
            }
            event.target.value = null;
        }

        function isPosInEvent(event, x, y) {
            // è€ƒè™‘æ»šåŠ¨åç§»é‡
            const adjustedY = y - scrollY;

            // æ£€æŸ¥ "å®Œæ•´" æˆ– "æ‚¬åœå±•å¼€" çš„äº‹ä»¶
            const isEffectivelyFull = (event.displayMode === 'full') || (event.displayMode === 'dot' && hoveringEvent === event);

            if (isEffectivelyFull) {
                if (event.deleteButtonPos) {
                    const dx = x - event.deleteButtonPos.x;
                    const dy = adjustedY - event.deleteButtonPos.y;
                    if (Math.sqrt(dx * dx + dy * dy) <= CONFIG.DELETE_BUTTON_RADIUS + 2) return true;
                }
                const bgBox = event.bboxes.background;
                if (bgBox && x >= bgBox.x && x <= bgBox.x + bgBox.w && adjustedY >= bgBox.y && adjustedY <= bgBox.y + bgBox.h) return true;
                const dx = x - event.x;
                const dy = adjustedY - event.y;
                if (Math.sqrt(dx * dx + dy * dy) <= CONFIG.NODE_RADIUS + 5) return true;
            } else if (event.displayMode === 'dot') {
                const actualRadius = CONFIG.NODE_RADIUS * (event.animState && event.animState.dot ? event.animState.dot.scale : 1);
                const dx = x - event.x;
                const dy = adjustedY - event.y;
                if (Math.sqrt(dx * dx + dy * dy) <= actualRadius + 5) return true;
            }
            return false;
        }

        function checkHover(x, y) {
            // è€ƒè™‘æ»šåŠ¨åç§»é‡
            y += scrollY;

            // 1. ä¼˜å…ˆæ£€æŸ¥å½“å‰æ‚¬åœäº‹ä»¶
            if (hoveringEvent) {
                if (isPosInEvent(hoveringEvent, x, y)) {
                    if (hoveringEvent.deleteButtonPos) {
                        const dx = x - hoveringEvent.deleteButtonPos.x;
                        const dy = y - hoveringEvent.deleteButtonPos.y;
                        if (Math.sqrt(dx * dx + dy * dy) <= CONFIG.DELETE_BUTTON_RADIUS + 2) {
                            return { type: 'deleteButton', event: hoveringEvent };
                        }
                    }
                    return { type: 'text', event: hoveringEvent };
                }
            }

            // 2. æ£€æŸ¥å…¶ä»–äº‹ä»¶
            for (let i = events.length - 1;i >= 0;i--) {
                const event = events[i];
                if (event === hoveringEvent) continue;

                if (isPosInEvent(event, x, y)) {
                    if (event.deleteButtonPos) {
                        const dx = x - event.deleteButtonPos.x;
                        const dy = y - event.deleteButtonPos.y;
                        if (Math.sqrt(dx * dx + dy * dy) <= CONFIG.DELETE_BUTTON_RADIUS + 2) {
                           return { type: 'deleteButton', event: event };
                        }
                    }
                    if (event.displayMode === 'dot') {
                        const actualRadius = CONFIG.NODE_RADIUS * (event.animState && event.animState.dot ? event.animState.dot.scale : 1);
                        const dx = x - event.x;
                        const dy = y - event.y;
                        if (Math.sqrt(dx * dx + dy * dy) <= actualRadius + 5) {
                           return { type: 'node', event: event };
                        }
                    }
                    return { type: 'text', event: event };
                }
            }

            // 3. æ£€æŸ¥Så‹è·¯å¾„
            for (const segment of pathSegments) {
                if (segment.type === 'line') {
                    if (Math.abs(y - segment.y1) <= CONFIG.LINE_WIDTH / 2 && x >= CONFIG.MARGIN && x <= canvas.clientWidth - CONFIG.MARGIN) {
                        return { type: 'path' };
                    }
                } else if (segment.type === 'arc') {
                    const dx = x - segment.cx;
                    const dy = y - segment.cy;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (Math.abs(dist - segment.radius) <= CONFIG.LINE_WIDTH / 2) {
                        return { type: 'path' };
                    }
                }
            }
            return null;
        }

        function handleCanvasMouseDown(e) {
            if (e.button === 0) { // å·¦é”®
                isDragging = true;
                dragStartY = e.clientY;
                scrollTopStart = scrollY;
                canvas.style.cursor = 'grabbing';
                e.preventDefault();
            }
        }

        function handleCanvasMouseUp(e) {
            if (e.button === 0) { // å·¦é”®
                isDragging = false;
                canvas.style.cursor = hoverTarget ? (hoverTarget.type === 'path' ? 'copy' : 'pointer') : 'default';
            }
        }

        function handleWindowMouseMove(e) {
            if (isDragging) {
                const deltaY = e.clientY - dragStartY;
                scrollY = scrollTopStart - deltaY * CONFIG.DRAG_SPEED;
                // é™åˆ¶æ»šåŠ¨èŒƒå›´
                scrollY = Math.max(0, scrollY);
                startAnimation();
            }
        }

        function handleCanvasWheel(e) {
            scrollY += e.deltaY * 0.5; // è°ƒæ•´æ»šåŠ¨é€Ÿåº¦
            // é™åˆ¶æ»šåŠ¨èŒƒå›´
            scrollY = Math.max(0, scrollY);
            startAnimation();
            e.preventDefault();
        }

        function handleCanvasMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const target = checkHover(x, y);

            if ((hoverTarget && hoverTarget.type === 'path' && !target)
                || (target && hoverTarget && hoverTarget.type !== target.type)
                || (target && target.type === 'path' && (currentMousePos.x !== x || currentMousePos.y !== y))) {
                isAnimating = true;
            }

            hoverTarget = target;
            currentMousePos = { x, y };
            hoveringDeleteButton = (hoverTarget && hoverTarget.type === 'deleteButton');

            if (hoverTimer) {
                clearTimeout(hoverTimer);
                hoverTimer = null;
            }

            if (hoverTarget) {
                canvas.style.cursor = (hoverTarget.type === 'path') ? 'copy' : 'pointer';
                const newHoverEvent = hoverTarget.event || null;

                if (hoveringEvent !== newHoverEvent) {
                    hoveringEvent = newHoverEvent;
                    isAnimating = true; // åªåœ¨æ‚¬åœäº‹ä»¶å˜åŒ–æ—¶è§¦å‘åŠ¨ç”»
                } else if (hoverTarget.type === 'deleteButton' || hoveringDeleteButton) {
                    isAnimating = true; // åœ¨åˆ é™¤æŒ‰é’®çŠ¶æ€å˜åŒ–æ—¶è§¦å‘åŠ¨ç”»
                }
            } else {
                canvas.style.cursor = 'default';
                const wasHoveringDeleteButton = hoveringDeleteButton;
                hoveringDeleteButton = false;

                if (hoveringEvent) {
                    hoverTimer = setTimeout(() => {
                        hoveringEvent = null;
                        hoverTimer = null;
                    }, CONFIG.HOVER_DELAY);
                }
            }
        }

        function handleCanvasMouseLeave() {
            if (!isDragging) {
                if (hoveringEvent) { hoveringEvent = null; }
                if (hoveringDeleteButton) { hoveringDeleteButton = false; }
                if (hoverTimer) { clearTimeout(hoverTimer);hoverTimer = null; }
            }
        }

        function handleCanvasClick(e) {
            if (isDragging) {
                isDragging = false;
                canvas.style.cursor = hoverTarget ? (hoverTarget.type === 'path' ? 'copy' : 'pointer') : 'default';
                return;
            }

            if (hoverTarget) {
                if (hoverTarget.type === 'deleteButton') {
                    if (window.confirm(`ç¡®å®šè¦åˆ é™¤äº‹ä»¶ "${hoverTarget.event.description}" å—ï¼Ÿ`)) {
                        deleteEvent(hoverTarget.event);
                    }
                } else if (hoverTarget.event) {
                    editingEvent = hoverTarget.event;
                    editingType = 'edit';
                    openModal();
                } else if (hoverTarget.type === 'path') {
                    // è€ƒè™‘æ»šåŠ¨åç§»é‡
                    const adjustedY = currentMousePos.y + scrollY;
                    editingEvent = {
                        timestamp: getTimeAtCoords(currentMousePos.x, adjustedY),
                        priority: 5,
                        description: ""
                    };
                    editingType = 'add';
                    openModal();
                }
            }
        }

        function openModal() {
            if (!editingEvent) return;
            if (editingType === 'add') {
                modalTitle.textContent = "æ·»åŠ æ–°äº‹ä»¶";
                eventDateInput.value = toLocalISOString(new Date(editingEvent.timestamp));
                eventPriorityInput.value = 2; // é»˜è®¤ä¸­ç­‰
                eventDescriptionInput.value = "";
            } else {
                modalTitle.textContent = "ç¼–è¾‘äº‹ä»¶";
                eventDateInput.value = toLocalISOString(new Date(editingEvent.timestamp));
                eventPriorityInput.value = editingEvent.priority;
                eventDescriptionInput.value = editingEvent.description;
            }
            // æ‰‹åŠ¨è§¦å‘ä¸€æ¬¡ change äº‹ä»¶æ¥è®¾ç½®åˆå§‹é¢œè‰²
            eventPriorityInput.dispatchEvent(new Event('change'));

            eventModal.classList.remove('opacity-0', 'scale-95', 'pointer-events-none');
            setTimeout(() => eventDescriptionInput.focus(), 100);
        }

        function closeModal() {
            eventModal.classList.add('opacity-0', 'scale-95', 'pointer-events-none');
            editingEvent = null;
        }

        function handleSaveEvent(e) {
            e.preventDefault();
            if (!editingEvent) return;

            const newDateStr = eventDateInput.value;
            const newTimestamp = new Date(newDateStr).getTime();
            const newPriority = parseInt(eventPriorityInput.value, 10);
            const newDescription = eventDescriptionInput.value;

            // éªŒè¯è¾“å…¥
            if (!newDateStr) {
                showError("è¯·è¾“å…¥æ—¥æœŸå’Œæ—¶é—´");
                return;
            }

            if (isNaN(newTimestamp)) {
                showError("è¯·è¾“å…¥æœ‰æ•ˆçš„æ—¥æœŸå’Œæ—¶é—´");
                return;
            }

            if (isNaN(newPriority) || newPriority < 0 || newPriority > 5) {
                showError("ä¼˜å…ˆçº§å¿…é¡»æ˜¯0-5ä¹‹é—´çš„æ•°å­—");
                return;
            }

            if (!newDescription) {
                showError("è¯·è¾“å…¥äº‹ä»¶æè¿°");
                return;
            }

            if (editingType === 'add') {
                const newEvent = createEventObject(
                    `evt_${events.length}`,
                    newDateStr,
                    newTimestamp,
                    newPriority,
                    newDescription
                );
                events.push(newEvent);
            } else {
                editingEvent.dateStr = newDateStr;
                editingEvent.timestamp = newTimestamp;
                editingEvent.priority = newPriority;
                editingEvent.description = newDescription;
            }

            updateDataAndRedraw();
            closeModal();

            cachedEventLayouts.clear();
            needsLayoutUpdate = true;
            startAnimation();
        }

        function deleteEvent(eventToDelete) {
            events = events.filter(e => e.id !== eventToDelete.id);
            hoveringEvent = null;
            hoveringDeleteButton = false;

            eventToDelete.bboxes = null;
            eventToDelete.deleteButtonPos = null;

            updateDataAndRedraw();
            cachedEventLayouts.clear();
            needsLayoutUpdate = true;
        }

        function updateDataAndRedraw() {
            if (events.length === 0) {
                let thisYear = new Date();
                minTime = thisYear().setMonth(0, 1).getTime();
                maxTime = new Date(thisYear.getFullYear() + 1, 0, 1).getTime();
            } else {
                let tempMin = Infinity;
                let tempMax = -Infinity;
                events.forEach(e => {
                    if (e.timestamp < tempMin) tempMin = e.timestamp;
                    if (e.timestamp > tempMax) tempMax = e.timestamp;
                });
                if (tempMin === tempMax) {
                    minTime = tempMin - 86400000;
                    maxTime = tempMax + 86400000;
                } else {
                    const padding = (tempMax - tempMin) * 0.05 || 86400000;
                    minTime = tempMin - padding;
                    maxTime = tempMax + padding;
                }
            }
            events.sort((a, b) => a.timestamp - b.timestamp);
            resizeCanvas();
        }

        function toLocalISOString(date) {
            const tzOffset = date.getTimezoneOffset() * 60000;
            const localDate = new Date(date.getTime() - tzOffset);
            return localDate.toISOString().slice(0, 19);
        }

        // æ·»åŠ é”™è¯¯æ˜¾ç¤ºå‡½æ•°
        function showError(message) {
            // åˆ›å»ºæˆ–æ›´æ–°é”™è¯¯æ¶ˆæ¯å…ƒç´ 
            let errorElement = document.getElementById('formError');
            if (!errorElement) {
                errorElement = document.createElement('div');
                errorElement.id = 'formError';
                errorElement.className = 'text-red-500 text-sm mt-2';
                eventForm.appendChild(errorElement);
            }
            errorElement.textContent = message;

            // 3ç§’åè‡ªåŠ¨æ¸…é™¤é”™è¯¯æ¶ˆæ¯
            setTimeout(() => {
                if (errorElement.parentNode) {
                    errorElement.parentNode.removeChild(errorElement);
                }
            }, 3000);
        }

        init();
    </script>
</body>
</html>
